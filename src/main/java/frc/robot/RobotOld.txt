// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.TalonFX;

import edu.wpi.first.cameraserver.CameraServer;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 * The VM is configured to automatically run this class, and to call the functions corresponding to
 * each mode, as described in the TimedRobot documentation. If you change the name of this class or
 * the package after creating this project, you must also update the build.gradle file in the
 * project.
 */


public class RobotOld extends TimedRobot {
    // Initialize objects

    Joystick controller = new Joystick(0);
    AHRS gyroscopeAhrs = new AHRS(SPI.Port.kMXP);

    // ? Configuration Variables
    // * GENERAL

    // * AUTONOMOUS
    // Generic
    final int initialState = 0; // Initial state when autonomous is enabled (used for debugging usually)
    // Movement
    // Movement Control
    // Logic
    // Timing

    // * TELEOP
    // Movement
    // Logic
    // Timing

    // ? Runtime Variables
    int autonomousState, armPosIndex;
    double pitchDegrees, lastPitchDegrees, errorSum, initialArmPos, lastRunTime, lastDebugOutputTime;
    boolean waiting, lastUpper, offsetOverride;

    /**
     * Turn the robot automatically. Call this function periodically while trying to turn.
     * @param speed Speed to turn at.
     * @param degrees Amount of degrees to turn, not 100% precise. Do not do more than 180 degree turns (this isn't made for it -- at least not yet)
     * @param initial Whether this is the first time the function is called
     * @return True if turning is complete, false otherwise
     */
    private boolean turnRobot(double speed, int degrees, boolean initial) {
        if (initial) {
            setMotorSpeedCorrected(0); // Stop moving, to ensure proper zeroYaw() placement
            gyroscopeAhrs.zeroYaw(); // Reset YAW to current face
            if (degrees < 0) { // Left turn
                setLeftMotorSpeed(-speed);
                setRightMotorSpeed(-speed);
            } else if (degrees > 0) { // Right turn
                setLeftMotorSpeed(speed);
                setRightMotorSpeed(speed);
            }
        }
        
        return (degrees < 0) ? degrees - gyroscopeAhrs.getYaw() >= 0 : gyroscopeAhrs.getYaw() - degrees >= 0;
    }

    /**
     * Turn the robot arm automatically. Call this function periodically while trying to turn. The arm motor came straight from hell.
     * @param speed Speed to turn at.
     * @param targetPosition Position to move the arm to
     * @param initial Whether this is the first time the function is called
     * @return True if turning is complete, false otherwise
     */
    private boolean turnArm(double speed, int targetPosition, boolean initial) {
        if (targetPosition == 1) { // Middle
            setArmMotorSpeed(speed);
            return true;
        } else { // Low
            setArmMotorSpeed(0);
            return true;
        }
    }

    /**
     * This function is run when the robot is first started up and should be used for any
     * initialization code.
     */
    @Override
    public void robotInit() {
    }

    @Override
    public void robotPeriodic() {
    }

    @Override
    public void autonomousInit() {
        /* 
         * State (used to determine operations in periodic)
         * 0 - Initialization
         * 1 - Moving to Charging
         * 2 - Charging Station Docking
         * 3 - Done Docking (in theory)
         * -1 - Error State
         * -2 - "Dumb" Autonomous (move forward out of community and gain a few points)
         */
        autonomousState = initialState;
        lastRunTime = 0;
        waiting = false;
        if (debugMode)
            System.out.println("Autonomous Initialization Complete");
    }

    @Override
    @SuppressWarnings("all") // I'm not wrong, you're wrong. Get rid of squiggly lines from config variables ("dead code", "unused code", "redundant check")
    public void autonomousPeriodic() {
        if (!gyroscopeAhrs.isConnected()) { // If gyro is not connected, return
            System.out.println("[AUTONOMOUS] ERROR: Gyro is not connected!");
            return;
        }
        if (debugMode && Timer.getFPGATimestamp() - lastDebugOutputTime >= debugOutputPrintInterval) {
            System.out.printf("Current Autonomous State: %d%n", autonomousState);
            lastDebugOutputTime = Timer.getFPGATimestamp();
        }

        double curTime = Timer.getFPGATimestamp();
        double pitchDegrees = ((useRoll) ? gyroscopeAhrs.getRoll() : gyroscopeAhrs.getPitch()) * (upsideDownGyro ? -1 : 1);

        // READ THIS vv
        // WARNING: Using a switch statement here causes the god of all confusing bugs to appear. Literally no idea why.
        // READ THIS ^^
        if (autonomousState == -2) { // "Dumb" Autonomous (Budget Points)
            if (lastRunTime == 0) { // Initial
                setMotorSpeedCorrected(autonomousMoveSpeed); 
                lastRunTime = curTime;
            }
            else if (curTime - lastRunTime >= timeToNonCommunity) {
                setMotorSpeedCorrected(0);
                autonomousState = -1; // Error State
            }
        }

        lastPitchDegrees = pitchDegrees;
    }

    @Override
    public void teleopInit() {
        if (debugMode) {
            gyroscopeAhrs.zeroYaw();
            System.out.println("Teleoperator Mode Initialized, set gyro to zero Yaw");
        }
        lastDebugOutputTime = 0;

        armPosIndex = 0;
        offsetOverride = false;
        setMotorSpeedCorrected(0);
    }

    @Override
    @SuppressWarnings("unused") // I'm not wrong, you're wrong. Get rid of squiggly lines from config variables ("dead code", "unused code", "redundant check")
    public void teleopPeriodic() {
        double curTime = Timer.getFPGATimestamp();
        double armCurPos = armMotor.getSelectedSensorPosition() - initialArmPos;

        // ARM
        if (armPosIndex != -1 && (armTurnSpeed < 0 && armMotor.getSelectedSensorPosition() <= armPosLimit 
                || armTurnSpeed > 0 && armMotor.getSelectedSensorPosition() >= armPosLimit)) { // Fail-safe hard limit
            armMotor.set(ControlMode.PercentOutput, 0);
        }
        if (armPosIndex != -1) {
            try {
                double targetPos = armPosVals[armPosIndex];
                if (armCurPos < targetPos - armPosTolerance)
                    armMotor.set(ControlMode.PercentOutput, armTurnSpeed);
                else
                    armMotor.set(ControlMode.PercentOutput, 0);
            } catch (ArrayIndexOutOfBoundsException e) {
                System.out.println("Arm Position Index Out of Bounds");
                armMotor.set(ControlMode.PercentOutput, 0);
                armPosIndex = -1;
            }
        }
        if (controller.getRawButtonPressed(5)) // L1 - Lowest
            armPosIndex = 0;
        else if (controller.getRawButtonPressed(6)) // L2 - Highest
            armPosIndex = 1;
        if (controller.getRawButton(1)) // X - Manual Override Up
            armMotor.set(ControlMode.PercentOutput, armTurnSpeed);
        else if (controller.getRawButton(4)) // Y - Manual Override Down
            armMotor.set(ControlMode.PercentOutput, -armTurnSpeed);
        else if (armPosIndex == -1)
            armMotor.set(ControlMode.PercentOutput, 0);
        if (controller.getRawButtonPressed(2)) // A - Reset Arm Low Encoder Pos
            initialArmPos = armMotor.getSelectedSensorPosition();
        // R2 - Speed Offset Manual Override
        if (controller.getRawButtonPressed(8)) {
            offsetOverride = true;
            if (debugMode) System.out.println("Speed Offset Manual Override Activated");
        } else if (controller.getRawButtonReleased(8)) {
            offsetOverride = false;
            if (debugMode) System.out.println("Speed Offset Manual Override Deactivated");
        }

        // DEBUG
        if (debugMode && curTime - lastDebugOutputTime >= lastDebugOutputTime) {
            System.out.printf(
                "===%nPitch: %f%nYaw: %f%nRoll: %f%nController Left: %f%nController Right: %f%nArm Motor Pos: %f%n",
                gyroscopeAhrs.getPitch(), gyroscopeAhrs.getYaw(), gyroscopeAhrs.getRoll(), stickLeft, stickRight, armMotor.getSelectedSensorPosition()
            );
            lastDebugOutputTime = curTime;
        }
    }
}
